<!-- https://gkocot.github.io/fish/fish.html?width=12&height=6&players=2&pawns=2 -->
<!DOCTYPE html>
<html>
    <head>
        <style>        
            *, *::before, *::after {
                margin: 0;
                padding: 0;
                border: 0;
                box-sizing: border-box;
                font-size: 0;
            }

            body {
                background-color: cornflowerblue;
            }

            .game {
                margin-top: 30px;
                margin-left: 30px;
                margin-bottom: 100px;
            }

            .board {
                text-align: center;
                display: inline-block;

                /* DEBUG */
                /* border-width: 1px; */
                /* border-color: black; */
                /* border-style: solid; */
            }

            .row {
                margin-bottom: 24px;
            }

            .cell {
                width: 100px;
                height: 100px;
                text-align: center;
                display: inline-block;
                position: relative;
                margin-left: 21px;
                margin-top: 21px;
            }

            .cell:nth-child(even) {
                top: 72px;
            }

            .hex_tile,
            .hex_img {
                display: inline-block;             
                clip-path: polygon(25% 5%, 75% 5%, 100% 50%, 75% 95%, 25% 95%, 0% 50%);
                top: 50%;
                left: 50%;
                position: absolute;
                transform: translate(-50%, -50%);
            }

            .hex_tile {                
                width: 160%;
                height: 160%;
                background-color:aqua;
            }

            .valid_target:hover {
            }

            .bgcolor_player0 {
                background-color: red;
            }

            .bgcolor_player1 {
                background-color: green;
            }
            .bgcolor_player2 {
                background-color: blue;
            }
            .bgcolor_player3 {
                background-color: yellow;
            }

            .color_player0 {
                color: red;
            }

            .color_player1 {
                color: green;
            }
            .color_player2 {
                color: blue;
            }
            .color_player3 {
                color: yellow;
            }

            .hex_img {
                width: 90%;
                height: 90%;
            }

            .hex_img_pawn {
                opacity: 0.9
            }

            .hex_img_active_pawn {
                opacity: 0.5
            }

            .scoreboard {
                margin-left: 60px;
                display: inline-block;
                position: absolute;
            }

            .score {
                font-size: 30px;
                position: relative;
                padding-left: 30px;
                padding-right: 30px;
            }

            .score:hover {
                background-color: aqua;
            }

            .active_player {
                background-color: aqua;
            }
        </style>
    </head>
    <body>
        <div class="game">
            <div class="board"></div><div class="scoreboard"></div>
        </div>
    </body>
    <script>
        // TBD: Move inside Game class.
        let player_index = 0;
        let finish_mode = -1;

        const params = new URLSearchParams(window.location.search);
        const width = params.get('width');
        const height = params.get('height');
        const nplayers = params.get('players');
        const npawns = params.get('pawns');

        // TBD: Check nplayers;

        class Player {
            constructor(player_number) {
                this.player_number = player_number;
                this.score = 0;
                this.state = 0; // state < npawns => set pawn n, state == npawns => play 
                this.active_pawn_hex_tile = null;
            }

            isValidTarget(hex_tile) {
                let coordinates2 = yxFromId(hex_tile.id);
                let y2 = coordinates2[0];
                let x2 = coordinates2[1];

                // When setting pawns, any unocupied tile can be selected.
                if (this.state < npawns) {
                    return board[y2][x2] == -1;
                }
                else {
                    let coordinates1 = yxFromId(this.active_pawn_hex_tile.id);
                    let y1 = coordinates1[0];
                    let x1 = coordinates1[1];

                    return isValidPath(x1, y1, x2, y2);
                }
            }

            setPawnOnTile(hex_tile) {                
                let coordinates = yxFromId(hex_tile.id);
                let y = coordinates[0];
                let x = coordinates[1];

                if (this.active_pawn_hex_tile != null) {
                    let hex_img = this.active_pawn_hex_tile.firstElementChild;
                    hex_img.classList.remove('hex_img_active_pawn');
                    hex_img.classList.add('hex_img_pawn');
                }

                hex_tile.classList.add('bgcolor_player' + this.player_number);
                let hex_img = hex_tile.firstElementChild;
                hex_img.classList.add('hex_img_active_pawn');
                this.active_pawn_hex_tile = hex_tile;

                board[y][x] = this.player_number;
            }

            updateScore() {
                let hex_tile = this.active_pawn_hex_tile;

                // Get the image source of selected element, the names are '<path>/1fish.jpg', '<path>/2fish.jpg' ...
                // The value for updating score is the 1st character after the last '/'.
                let hex_img = hex_tile.firstElementChild;
                this.score = this.score + parseInt(hex_img.src.charAt(hex_img.src.lastIndexOf('/') + 1));

                let scoreboard = document.querySelector('.scoreboard');
                scoreboard.childNodes[player_index].innerHTML = 'Score: ' + this.score;

                // Hide the previously selected element.
                hex_tile.style.visibility = 'hidden';                
            }

            selectElement(hex_tile) {
                let coordinates = yxFromId(hex_tile.id);
                let y = coordinates[0];
                let x = coordinates[1];

                // Setting pawns phase.
                if (this.state < npawns) {                    
                    if (this.isValidTarget(hex_tile)) {
                        this.state += 1;

                        this.setPawnOnTile(hex_tile);
                        return true;
                    }
                }

                // One of player's pawns selected again.
                if (board[y][x] == this.player_number) {
                    this.setPawnOnTile(hex_tile);
                    return false;
                }

                // Playing game phase.
                if (this.isValidTarget(hex_tile)) {
                    this.updateScore();
                    this.setPawnOnTile(hex_tile);
                    return true;
                }

                return false;
            }
        }

        // TBD: Generate nplayers instead of fixed number of players
        let players = [
            new Player(0),
            new Player(1),
            new Player(2),
            new Player(3)
        ];

        let board = [];
        for (let i = 0; i < height; ++i) {
            board[i] = [];
            for (let j = 0; j < width; ++j) {
                board[i][j] = -1;
            }
        }

        setBoard(width, height, nplayers);

        function tileOnMouseover(e) {
            // Static variable first initialization
            if (typeof tileOnMouseover.hex_tile == 'undefined') {
                tileOnMouseover.hex_tile = null;
            }

            // Remove previously highlighted tile if any
            if (tileOnMouseover.hex_tile != null) {
                tileOnMouseover.hex_tile.classList.remove('valid_target');
                
                let coordinates = yxFromId(tileOnMouseover.hex_tile.id);
                let y = coordinates[0];
                let x = coordinates[1];
                
                // Don't remove color from selected tiles
                if (board[y][x] == -1) {
                    tileOnMouseover.hex_tile.classList.remove('bgcolor_player0');
                    tileOnMouseover.hex_tile.classList.remove('bgcolor_player1');
                    tileOnMouseover.hex_tile.classList.remove('bgcolor_player2');
                    tileOnMouseover.hex_tile.classList.remove('bgcolor_player3');
                }
            }

            // Highlight new tile it it is a valid target for active player
            let hex_tile = hexTileFromEvent(e);
            let player = players[player_index];
            if (player.isValidTarget(hex_tile)) {
                tileOnMouseover.hex_tile = hex_tile;
                hex_tile.classList.add('valid_target');
                hex_tile.classList.add('bgcolor_player' + player_index);
            }
        }

        function hexTileFromEvent(e) {
            // Either .hex_tile or .hex_image can be clicked, so to always select the .hex_tile
            // we find the most nested element which is .hex_image and select its parent.
            let element = e.target;

            while (element.firstElementChild) {
                element = element.firstElementChild;
            }
            
            return element.parentElement;
        }

        function tileOnClick(e) {
            let hex_tile = hexTileFromEvent(e);
            let player = players[player_index];
            if (player.selectElement(hex_tile)) {
                if (finish_mode == -1) {
                    setPlayer((player_index + 1) % nplayers);
                }
            }
        }

        function scoreOnClick(e) {
            let score = e.target;
            // Get the player index from score id (the last number) e.g. 'score_player0'.
            finish_mode = parseInt(score.id.substring(score.id.length - 1));
            setPlayer(finish_mode);
        }

        function setPlayer(next_player) {
                let score = document.querySelector('#score_player' + player_index);
                score.classList.remove('active_player');
                player_index = next_player;
                score = document.querySelector('#score_player' + player_index);
                score.classList.add('active_player');
        }

        function setBoard(width, height, nplayers) {
            let board = document.querySelector('.board');

            for (j = 0; j < height; ++j) {
                let row = document.createElement('div');
                row.className = 'row';
                for (i = 0; i < width; ++i) {
                    let cell = document.createElement('div');
                    cell.className = 'cell';

                    let hex_tile = document.createElement('div');
                    hex_tile.className = 'hex_tile';
                    hex_tile.id = '_' + j + '_' + i;
                    hex_tile.addEventListener('click', tileOnClick, false);
                    hex_tile.addEventListener('mouseover', tileOnMouseover, false);
                
                    let hex_img = document.createElement('img');
                    hex_img.className = 'hex_img';
                    let n = Math.floor(Math.random() * 3) + 1;   
                    hex_img.src = n + 'fish.jpg';

                    hex_tile.appendChild(hex_img);
                    cell.appendChild(hex_tile);
                    row.appendChild(cell);
                }
                board.appendChild(row);
            }

            let scoreboard = document.querySelector('.scoreboard');

            for (k = 0; k < nplayers; ++k) {
                let score = document.createElement('div');
                score.id = 'score_player' + k;
                score.className = 'score';
                if (k == 0) {
                    score.classList.add('active_player');
                }
                score.classList.add('color_player' + k);
                score.innerHTML = 'Score: 0';
                score.addEventListener('click', scoreOnClick, false);
                scoreboard.appendChild(score);
            }
        }

        function yxFromId(id) {
            return id.substring(1).split('_').map(x => +x);
        }

        // Check if valid path exists from position A:(y1,x1) to position B:(y2,x2).
        // No gaps or other playier on the path from  A to B.
        function isValidPath(x1, y1, x2, y2) {
            // The same tile selected again.
            if (x1 == x2 && y1 == y2)
                return false;

            // We are walking either up/down the column or along |x| = |2y| diagonals (with +/- margin).
            // Walking the rows is divided into step1 (dx, dy1) and step2 (dx, dy2).
            // Depending on ralative position of points A and B we need appropriate values for dx, dy1 and dy2.
            let dx = 0; // Move up/down in the column.
            if (x2 < x1) dx = -1; // Move left.
            if (x2 > x1) dx = 1; // Move right.
            
            if (x1 == x2) {                
                // Move up/down in the column.
                if (y2 > y1) {
                    // Move down.
                    dy1 = 1;
                    dy2 = 1;
                }
                if (y2 < y1){
                    // Move up.
                    dy1 = -1;
                    dy2 = -1;
                }
            }
            else {
                // Move along the diagonals.
                if (x1 % 2) {
                    if (y2 > y1) {
                        dy1 = 1;
                        dy2 = 0;
                    }
                    else {
                        dy1 = 0;
                        dy2 = -1;
                    }
                }
                else {
                    if (y2 >= y1) {
                        dy1 = 0;
                        dy2 = 1;
                    }
                    else {
                        dy1 = -1;
                        dy2 = 0;
                    }
                }
            }

            while (x1 != x2 || y1 != y2) {
                if (typeof board[y1 + dy1] !== 'undefined' &&
                    typeof board[y1 + dy1][x1 + dx] !== 'undefined' &&
                    board[y1 + dy1][x1 + dx] == -1) {
                    x1 += dx;
                    y1 += dy1;
                }
                else {
                    return false;
                }
                
                if (x1 != x2 || y1 != y2) {
                    if (typeof board[y1 + dy2] !== 'undefined' &&
                        typeof board[y1 + dy2][x1 + dx] !== 'undefined' &&
                        board[y1 + dy2][x1 + dx] == -1) {
                        x1 += dx;
                        y1 += dy2;
                    }
                    else {
                        return false;
                    }
                }
            }

            return true;
        }
    </script>
</html>